= Order/Invoice validation + immutability
:toc: right
:_basedir: ./


This discussion paper aims to clarify the rules to apply when linking orders and invoices.
It also tackles how changes to either orders or invoices should be handled once they are have become immutable (due to accounting/reporting or treasury).



== Business Problem

The original motivation included these two related issues:

* (EST-1571) discover that the seller was incorrect on an Order; needs fixing
* (EST-1602) realise that an order should be discarded (eg is a duplicate scan), but it has already been marked as completed/approved

There are some related issues to do with making Estatio more user-friendly by defaulting information where possible.


Thinking about how an Order or an Invoice can be modified takes us on to the additional constraints that need to be considered when an Order or an Invoice has become immutable.
This then is the second "half" of this paper.




== Terminology


"Dimensions" are a means of characterising an order or an invoice.

* defined at parent level, ie `Invoice` or the `Order`:

** seller party (also called supplier)


* defined at item level `InvoiceItem` or the `OrderItem` :

** property
** charge
** project
** budget
** period


Invoice type, determines the approval cycle; also determines which dimensions are mandatory/must be left blank.

* capex/service charge/property expense
** capex: project is required, budget is blank
** service charge: project is blank, budget is required
** property expense: neither is required
* local expense
* corporate expense




== Reasons why data become immutable:

=== Internal ("soft")

The first main reason why we treate data is immutable is that it has gone through an approval cycle.
However, this is only a "soft" constraint, because we allow Invoices to be rejected, sent back to fix a data issue, and therefore to go round the loop.

We also intend to do the same for Orders (though rather than "reject" an Order, the terminology is "fix error").
Send an Order back to be fixed also means it can be discarded.


[plantuml,order-approval-state-chart,png]
--
state "Order Approval" as oa {

    state "NEW" as oa_new

    state "APPROVED" as oa_approved
    note right of oa_approved: immutable at this point on

    state "DISCARDED" as oa_discarded
    note right of oa_discarded: associated document\nalso discarded

    [*] -right-> oa_new: INSTANTIATE

    oa_new -down-> oa_approved: COMPLETE_WITH_APPROVAL
    oa_approved -up-> oa_new: FIX_ERROR
    oa_new -right-> oa_discarded : DISCARD

}
--



=== External ("hard")

The other reason why data becomes be treated as immutable is when it has been reported/sync'd over to another system/organisation external to estatio.


Strictly speaking, we could distinguish between:

* extra-ECP : ie to another system outside of ECP, eg IBP.

* intra-ECP : ie to another system (eg CODA) that is nevertheless within ECP.

Probably PWC could be thought of as an "internal" interaction.

For extra-ECP interactions, there's little to discuss: any adjustments that have to be made once the information has been extracted from Estatio will have to be done as reversals/deltas.
Credit notes are one "real-world" example of this.

For intra-ECP interactions, we have more options, so should discuss them.
Since the automated software that will do the interaction is under our control, we _do_ have the option to keep Estatio simple/naive, and move the complexity into the "glue".
For example, rather than treating invoice items as immutable once reported (meaning that changes must be handled as reversals/deltas) we could if we wanted just post snapshots of the current state; ie always the "absolute" current view.
This makes Estatio simpler to use and simpler to maintain.

On the other hand, the downside is that there is "magic" within the glue: it would need to convert the snapshots of current state coming from Estation into reversals/deltas within CODA.
There are two consequences of this:

* from a business viewpoint, the information in Estatio vs CODA would look quite different, so would not facilitate conversations between Property Administration vs Accounting.

* from a technical viewpoint, it would likely be easier to put the complexity into Estatio than to have it sitting in the glue.

Therefore (as has been discussed anyway in meetings), although intra-ECP vs extra-ECP interactions are theoretically different, it makes the most sense to treat them the same.
Thus, whenever data is extracted from Estatio, for whatever purpose, then that data becomes immutable.
Any changes to it must then be done by reversing it out and reposting an amendment.



=== What actually is immutable?

The above analysis applies to items: Order items and Invoice Items

The parent objects of these, Order and Invoice, are treated as immutable if there is at least one item that is immutable.
For example, we cannot change the seller on an Order once one of its items has been reported to PWC.

On the other hand, the links between Order items and Invoice items are _never_ treated as immutable; Estatio allows these to be adjusted at any time.



== Rules for entering/modifying items

This is prior to them becoming immutable




********************************* UP TO HERE *********************************




== Order exists with none/some/all dimensions; we enter Capex Invoice + link

given:

* already have `Order` with some or all of these dimensions on it: seller, charge, project, budget item, (period)

* categorise `Invoice`:

** (a) enter order number, and it's valid
*** given list of order item for that order

** (b) enter seller
*** given list of order items of all of the orders not completely invoiced of that seller

* system then links the invoice item to that order item
** copies over from `Order` to `Invoice` based on the type of the invoice:
*** if invoice is capex,            copy over: seller, charge, project       (ignore budget item, period)
*** if invoice is service charge,   copy over: seller, charge, budget item   (ignore budget item, period)
*** if invoice is property expense, copy over: seller, charge   (ignore project, budget item, period)

* no link is created, just enter seller and dimensions onto the invoice



== What if link subsequently?

* for an unlinked Invoice Item

** if link, honour any and all dimensions that are specified on either side (ignoring period)

** perhaps some mechanism to allow a candidate order item's dimensions to be copied over easily (as an overwrite)
*** a UI improvement




== What if some dimensions have been added to the Invoice already?

* do we ignore them and just overwrite?

* do we use them to constrain the list of candidate order items?





== Handling Immutable datas


== Once Order (Item) still mutable + Invoice Item mutable + parent Invoice mutable, but is linked


* an improvement on this (defer for now):
** allow the invoice's charge to be one of the children of the order's charge



* on an order, change seller
** cascade onto the parent Invoice(s) of all of the linked items, so long as all are still mutable

* on an order item, change charge, project, budget item
** cascade onto the items, so long as still mutable (as needed by the type of the invoice)


* if change invoice?




== Once Order (Item) still mutable + Invoice Item now immutable, but is linked

* on the invoice, change the seller ... don't




== Once Order (Item) now immutable + Invoice Item mutable, but is linked

* on an order, change seller ... not allowed, because one of its items is immutable

* however, need to "back it out"
** on the old order, add a new -ve item(s) which backs out all of the order items that were on it
** creating a new order with the new seller, that has the same set of order items (but is now mutable)

** and then we link the mutable invoice item(s) to the new order item of the new order
** then we copy over the seller to the invoice item

* on an order item, change charge, project, budget item ... now allowed, as is immutable

* however, back out that one item
** add a new -ve item to back out this item
** add a new +ve item that's modifiable
** and, again, copy over the change to the invoice items linked to it


== Once Order (Item) now immutable + Invoice Item now immutable, but is linked





== what about many-to-many links?



== if merge suppliers

* need to cascade...




Order (seller A)
- OrderItem   100,000  CHARGE_1   PROJECT_2     reported_at=...   cancelled_at=...


Order (seller B)
- OrderItem   100,000  CHARGE_2   PROJECT_33    reported=N   << modifiable






Invoice (seller X)  < when paid by IBP, immutable
- item#1            < when paid by IBP, immutable


Invoice (seller X)  < when reported to PWC, still "mutable", ie can do reversals
- item#1            < when reported to PWC, immutable

Invoice (seller X)
- item#1            < when reported to PWC, immutable
- item#2            -ve amt, to back it out

Invoice (seller Y)
- item#3            +ve amt, now mutable



1. mis-enter the supplier on an order

2. link an invoice to that order

3. report this off to PWC, so this stuff is now immutable

4. then notice the error.  we don't let them make the order modifiable


















